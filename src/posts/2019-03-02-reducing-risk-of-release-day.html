---
layout: post
title:  "Reducing risk of release day"
subtitle: "Large changes do not have to fill you with fear"
date: 2019-03-02 22:30:00
categories: git workflows

---

<p>Sometimes planned changes are large, and you might initially think that there is no alternative other than for it all to go live at once, a few days, weeks, months (or even longer!) away. Ideally, the actual public changes of behaviour will be release incrementally to get feedback and to be able to iterate on this, but sometimes this just isn't possible. Three common ones are:</p>

<ul class="fa-ul">
  <li><i class="fa-li fa fa-caret-right"></i> a user-facing feature that is seemingly small, but actually needs large scale internal code changes;</li>
  <li><i class="fa-li fa fa-caret-right"></i> a larger user-facing feature-set that needs lots of UI and backend changes [often released at once for marketing reasons];</li>
  <li><i class="fa-li fa fa-caret-right"></i> a "private" property of an application that is seemingly all-or-nothing, such as bumping the version of a framework through a breaking change that requires large scale changes in the codebase.</li>
</ul>

<p>You can automated test, QA, or load test the large change all you like, but these checks are rarely a replacement for feedback from production: in terms of bugs but <em>especially</em> for performance. The performance characteristics of large swathes of code that has not run in production by large numbers of users can rarely be predicted.</p>

<p>However, you can often get feedback before the final change, simply splitting up the large change up so each is:</p>

<ul class="fa-ul">
  <li><i class="fa-li fa fa-caret-right"></i> small: ~1 day's work;</li>
  <li><i class="fa-li fa fa-caret-right"></i> released: so the code actually runs in production, and its result used;</li>
  <li><i class="fa-li fa fa-caret-right"></i> safe: reviewed/tested/QA-ed as you deem appropriate.</li>
</ul>

<p>[Even if you don't use any feedback from one change to inform the next, there is another benefit of splitting up changes like this: you reduce the chance of multiple bugs being released at the same. It's <em>far</em> more difficult to debug multiple related bugs rather than just one.]</p>

<p>There are two techniques you can use to split a large change into a set of small, released and safe changes, detailed below.</p>


<h3>Long-running feature branch [but keeping it as small as possible]</h3>

<p>A long-running feature branch is often the traditional way of doing large changes, periodically merging in any changes from the master branch. This is by far the worst technique. Not only are you essentially maintaining two versions of the application [similar to The Big Rewrite], but come release day, it will all hit production at once!</p>

<p>However, a variation of this can often have great properties that reduce risk on release day. Instead of periodically taking changes from master into the feature branch, do it the other way around. In more detail...</p>

<p>As you're working on a feature branch, always think about what could be released [and used in production] first, without changing the public behaviour. Put another way, try to refactor* the production code so it can run <em>both</em> the original behaviours, and the new ones, and release the refactoring before the actual feature is released.</p>

<p>Ideally, you can plan this: do the refactoring up-front, and then move onto the new behaviour that uses the refactored code. However this is often not possible: not until having written some of the feature do you then realise some parts of the code need to be refactored, and this should/could be released first. However, it can be tricky to reorder this: the refactoring done <em>second</em> is to be released <em>first</em>.</p>

<p>There is a technique that is especially helpful here: keep each commit small, releasable, and put test additions/changes in the same commit as the corresponding production code change. This requires a bit of diligence, and often use of <code class="inline">git rebase -i</code> to squash commits. If you do this, then it's <em>far</em> easier to re-order them safely, again using <code class="inline">git rebase -i</code>: the safety is achieved by running the tests* for each re-ordered commit to make sure everything works. So, if you do refactoring at the <em>end</em> of a feature branch, with small, releasable commits, you can then re-order the commits to put it at the <em>beginning</em>.</p>

<p>There may be conflicts, but if you fix them, run tests*, and it all works, then you should be able to separate out the refactoring commit(s) into a separate branch [<code class="inline">git cherry-pick</code> can be used for this], and go through your process to merge this into master and get it released. You then rebase your feature branch onto master, and ensuring to fix conflicts and making sure tests pass for each commit. At this point, master will contain the refactoring for the change, and the feature branch will just contain the (non refactoring) change. Repeat for as many refactorings as needed.</p>

<hr>

<p>The most extreme example of this that I've done was for Django upgrade of an application that was coupled to a lot of subtle/semi-private Django behaviour. To limit the risk of the Django upgrade + application code changes all going live at once, I repeatedly refactored the application code so the same code worked in both versions. Ultimately, there were about ~20 refactoring branches, each reviewed, QA-ed, and released, <em>before</em> the actual Django upgrade itself.</p>

<h3>Feature flag [minimising code behind flag]</h3>

<p>An alternative to a feature branch is a feature flag. This is in many ways similar to a feature branch, as in it's kept from running by most users. However, with a feature flag the code is deployed to the production application, but it's only run by certain users with a certain flag enabled. This is often acceptable at the beginning of a feature [say, to get feedback on the UI of a feature before it's fully working], but always consider what will happen on release day. On release day, the feature flag will be effectivly enabled for all users, and lots of code will be run by lots of users that wasn't before. For this reason, the code behind the feature flag should be minimised <em>before</em> release day: often to just the UI that enables the particular feature.</p>

<p>A great benefit of this technique is that often it is possible to incrementally refactor* a lot of the code out from behind the feature flag. Even if at the beginning there might be a fair bit of code behind the feature flag, you can go through several release/QA cycles, moving more and more of the code into production <em>before</em> release day.</p>


<hr>

<p>* It's important to have high-level feature/integration tests to support refactoring and safe rebasing. Low-level tests [often called unit tests] are less helpful.</p>
