---
layout: post
title:  "3 AngularJS E2E Testing Considerations"
subtitle: "Things to think about when end-to-end testing AngularJS applications using Protractor"
date: 2016-10-04 10:00:00
categories: angularjs e2e

---

<p>This post contains 3 things to consider when writing E2E tests for AngularJS applications. These are deliberatly not tips or statements of best-practice. My suggestion is to judge whether these are applicable in your situation.</p>

<h3>1a. Consider testing as a user: selecting elements as a user would</h3>

<blockquote>
  <p>Your scientists were so preoccupied with whether or not they could, they didnâ€™t stop to think if they should.</p>
  <cite>Ian Malcom, Jurassic Park</cite>
</blockquote>

<p>The protractor documentation suggests selecting HTML elements by repeater or (Angular) model variable name. I think this is unfortunate, as it makes the tests depend on internals of the page, which means if someone comes along and does a bit of refactoring, or uses something other than <code class="inline">ng-repeat</code> or <code class="inline">ng-modal</code>, the E2E tests will fail, even though the behaviour, from the users' points of view, is perfectly fine. I treat this similarly to the test depending on a variable name or process on the server. It seems quite silly for the test to be fragile with respect to that!</p>

<p>Instead, consider using minimal CSS or XPath selectors to pick elements as close as possible to how a user would. For example, the first <code class="inline">table</code> after a <code class="inline">h2</code> element with text content "Section 1".</p>

{{#highlight 'javascript'}}
table = element(by.xpath('//h2[text()="Section 1"]/following::table[1]'))
{{/highlight}}

<p>Or, if you have used a custom element for your UI widget directives, the first <code class="inline"><my-widget></my-widget></code> in the first <code class="inline"><nav></nav></code> of the page.<p>

{{#highlight 'javascript'}}
widget = element(by.xpath('//nav[1]//my-widget'))
{{/highlight}}

<p>Consider how specific you want the selectors to be. If you have only one  <code class="inline">my-widget</code> in the page, you can be more minimal in the selector</p>

{{#highlight 'javascript'}}
widget = element(by.xpath('//my-widget'))
{{/highlight}}

<p>This makes the test less fragile to moving the element around the page. If it's crucial to test where this is in the page, you could always have an explicit assertion for that.</p>

<p>Another technique is selecting elements using <code class="inline">cssContainingText</code>, say to find <code class="inline">button</code> that also has the text "Go to stage 2".

{{#highlight 'javascript'}}
message = element(by.cssContainingText('button', 'Go to stage 2'))
{{/highlight}}

<p>And as a last, but perhaps still common, resort, using a class.</p>

{{#highlight 'javascript'}}
message = element(by.cssContainingText('.message', 'Alert!'))
{{/highlight}}

<p>If using classes I recommend consisdering that they are as semantic as possible. This isn't just to make the HTML "nice": it's so that the tests continue to pass as long as the element behaves as it should, independent of any changes or internal refactoring or renaming of non-sematic (with respect to the UI) elements on the page.</p>

<p>I don't think it's a perfect solution: you might want to tweak the semantic names for custom elements and classes, but I suspect it's better for a lot of cases that depend on ng-repeat or ng-model.</p>

<h3>1b. Consider testing as a user: waiting for things as a user would</h3>

<p>If you're using Protractor, consider setting set <code class="inline">browser.ignoreSynchronization = true</code> for all tests. Yes, really. The magic Protractor gives you for the simple cases just isn't worth it, because the cases of having some sort of polling, or non Angular asynchronous code running, just makes you have multiple sorts of tests.</p>

<p>Instead, wait for changes in the page elements to appear on the screen. You can do this explicitly in your first few tests, but then you might want to factor the waiting out (see point 3) once you are clear what you're waiting for and commanilty between the cases you handle. Your tests will be less flakey to changes you might make in the application. Even, if you eventually decide to swap out Angular!</p>

{{#highlight 'javascript'}}
browser.ignoreSynchronization = true;
browser.wait(function () {
   return element(by.cssContainingText('.message', 'Stage 2')).isPresent()
});
{{/highlight}}

<p>Of course, if you're not using what Protractor builds on top of Selenium, then I would seriously consider just using plain Selenium. This has another advantage: removal of at least one dependency, if not <a href="https://github.com/angular/protractor/blob/master/package.json">more</a>.</p>

<h3>2. Keep expectations outside of promise callbacks</h3>

<p>Often I see code that has an expectation inside of a promise callback. There is the possibility, especially in a complex case, that the callback will not be reached. Failed promises in the control flow do cause errors when running the test, but they're not failures of the expectation, I don't see this point in the documentation, and at best, they add an extra bit of thought as to whether the expectation will actually be reached when the test is run.</p>

<p>For example, I think the following<p>

{{#highlight 'javascript'}}
element(by.xpath('//nav[1]//my-widget')).getText().then(function(text) {
  expect(text).toBe('Desired text')
});
{{/highlight}}

<p>Is better written to use a promise that resolves to the actual value you need to test</p>

{{#highlight 'javascript'}}
text = element(by.xpath('//nav[1]//my-widget')).getText()
expect(text).toBe('Desired text');
{{/highlight}}

<p>You can chain promises to process these values.</p>

{{#highlight 'javascript'}}
number = element(by.xpath('//nav[1]//my-widget')).getText().then(function(text) {
  return parseInt(text) * 2;
})
expect(number).toBe(24);
{{/highlight}}

<p>Or, if you have multiple values</p>

{{#highlight 'javascript'}}
number1 = element(by.xpath('//nav[1]//my-widget')).getText().then(function(text) {
  parseInt(text);
});
number2 = element(by.xpath('//nav[1]//my-other-widget')).getText().then(function(text) {
  parseInt(text);
});
multiplied = protractor.promise.all([number1, number2]).then(function(results) {
  return results[1] * results[2]; 
})
expect(multiplied).toBe(64);
{{/highlight}}

<p>If you have a test that depends on more complex processing, perhaps combining the text of multiple elements, keeping the final expectation at the top level keeps things clean and readable.</p>

<h3>3. Consider not using page objects, especially when learning or initially constructing your test suite.</h3>

<p>E2E testing is hard. Asynchronous programming is hard. Combining the two, which you would be doing if writing tests in node, is hard^2. If you're learning about both, and just have one test, I would consider avoiding page objects, or factoring out of any kind. If you suddenly have multiple layers of asynchrounous code that you don't understand well, you are less likely to get to the bottom of any bugs for flakiness in the E2E tests.</p>

<p>Just like optimization, premature refactoring can be bad. Instead, do
Continous/<a href="http://martinfowler.com/bliki/OpportunisticRefactoring.html">opportunistic refactoring</a>. Until you have 3 tests or more, you might not really be able to see what is common to them, and you might get yourself stuck in multiple layers of asynchronous test code that isn't particularly suited to your case.</p>

<p>Also, a "page", at least by name, may not be the right abstraction for finding elements or keeping state an an application. You might have a widget to test in a left menu panel, but it can also appear on the right, accessible from a different selector. You might want want a "UI Element" object that is constructed dynamically from a parent element. Or you might have different browser instances in play, and need to control different ones.</p>

<p>Finally, <a href="https://github.com/angular/protractor/blob/7b371fcd9e47904dd6e3a226edc70292f08a2547/docs/page-objects.md">The page object example in the documentation<a> suggests wrapping the non-semantic UI actions such as typing...</a>

  {{#highlight 'javascript'}}
    nameInput.sendKeys(name);
  {{/highlight}}

<p>... in functions with semantic names.</p>

  {{#highlight 'javascript'}}
    this.setName = function(name) {
      nameInput.sendKeys(name);
    };
  {{/highlight}}

<p>There are 2 problems with it. It hides the fact that the aim is testing like a user. The UI tests are low-level: it tests what happens when the user types, clicks, moves the mouse</p>

<p>Secondly, I have found that this can lead to a layer of code the only seems to obscure what it does, and then can be difficult to reason about. Keeping the tests as

<ul>
  <li>Finding the element(s)
  <li>Interacting with the element(s)
  <li>Asserting something about the UI
<ul>

<p>Essentially anything that hides what any lay

<p>As the application grows, and you have more elements and ways of interacting with them, this can lead to essentially wrapping protractor (which it itself a layer on selenium), with another layer that just 


<p>Of course, not planning up front has its critisisms.</p>

<blockquote>
  <p>I find that weeks of coding and
testing can save me hours of planning.</p>
  <cite>Someone</cite>
</blockquote>

<p>Of course, if you're an expert in promise-based asynchronous programming, know the <a href="https://github.com/angular/protractor/blob/master/docs/control-flow.md">control flow</a> like the back of your hand, and know what you're doing to be testing, you can probably reason and plan about the future testing requirements well, and do some of the refactoring up-front.</p>



