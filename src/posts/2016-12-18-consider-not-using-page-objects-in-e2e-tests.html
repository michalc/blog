---
layout: post
title:  "Reasons to not use page objects in E2E tests"
subtitle: "They can result in code that is harder to reason about"
date: 2016-12-18 10:00:00
categories: angularjs e2e

---

<p>Page objects seem to have gained a bit of traction in AngularJS E2E testing, especially since they seem to be <a href="https://github.com/angular/protractor/blob/7b371fcd9e47904dd6e3a226edc70292f08a2547/docs/page-objects.md">officially recommended</a>. In this post I offer a few reasons <em>not</em> to use them.

<blockquote>
  <p>Your scientists were so preoccupied with whether or not they could, they didnâ€™t stop to think if they should.</p>
  <cite>Ian Malcom, Jurassic Park</cite>
</blockquote>

<h3>Reason 1: They obscure behaviour</h3>

<p>Consider the <a href="https://github.com/angular/protractor/blob/7b371fcd9e47904dd6e3a226edc70292f08a2547/docs/page-objects.md">official example</a></p>

{{#highlight 'javascript'}}
var AngularHomepage = function() {
  var nameInput = element(by.model('yourName'));
  var greeting = element(by.binding('yourName'));

  this.get = function() {
    browser.get('http://www.angularjs.org');
  };

  this.setName = function(name) {
    nameInput.sendKeys(name);
  };

  this.getGreeting = function() {
    return greeting.getText();
  };
};
{{/highlight}}

<p>Because of the behaviour of <code class="inline">ElementFinder</code>, the elements are actually only retrieved when you call <code class="inline">setName</code> or <code class="inline">getGreeting</code>. Of course you know this, since you know how Protractor behaves, and can see the code of the page object. But you could have this information much closer to the test rather than elsewhere. When you have more complex page behaviour, with elements appearing and disappearing due to non-trial behaviour, being completely clear on when elements are being retrieved, it is very important to keep the tests maintainable, and making sure that they are doing what you think they're doing.</p>

<h3>Reason 2: They obscure state</h3>

<p>By nature of being objects, they promote keeping an internal state, exposed by an interface. You might not be able to get away from having some state in your test: it's asynchronous and you might have to check something survives from one point in time to the next. However, you should be able to keep it all in the main body of the test, keeping only the state you need for that particular test.</p>

<p>Conder the example above. As mentioned, the elements are actually found on the page when you call <code class="inline">setName</code> or <code class="inline">getGreeting</code>, and you are offered no way to "refind" an element, say if it is temporarily removed and a new one added to the DOM. Of course, you can create another page object, or add a method to do it, 

{{#highlight 'javascript'}}
this.refindNameInput = function() {
  nameInput = element(by.model('yourName'))
};
{{/highlight}}

<p>but doing this means that you are completely leaking how the page object handles state internally. Encapsulation has offered little but another layer of code between the test and what it's doing.</p>

<h3>Reason 3: They hide what you're actually testing</h3>

<p>Finally, <a href="https://github.com/angular/protractor/blob/7b371fcd9e47904dd6e3a226edc70292f08a2547/docs/page-objects.md">The page object example in the documentation<a> suggests wrapping the non-semantic UI actions such as typing...</a>

{{#highlight 'javascript'}}
nameInput.sendKeys(name);
...
greeting.getText();
{{/highlight}}

<p>... in functions with semantic names.</p>

{{#highlight 'javascript'}}
this.setName = function(name) {
  nameInput.sendKeys(name);
};

this.getGreeting = function() {
  return greeting.getText();
};
{{/highlight}}

<p>The main problems is that it's needlessly hiding how the object is interacting with the elements on the page and where the object gets its data.</p>

<p>As the application grows, and you have more elements and ways of interacting with them, combinations of key presses, mouse movements, and different and more complex ways of giving output, this can lead to your page objects exposing a lot of what you meant to hide in the first place.</p>

<h3>Reason 4: You are spending time coding for a case of many E2E tests that should never happen</h3>

<p>It is usually recommended to <a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html"><em>not</em> have that many E2E tests</a>. Essentially if you have a very small amount of E2E tests for each part of your application, then spending time for some future "what if we do this 100s of times" cases is effort that has the primary effect of making it harder to reason about each test that you do have.</p>

<h3>Reason 5: They might not be the right abstraction for your cases</h3>

<p>A "page", at least by name, may not be the right abstraction for finding or interacting with elements in an application. You might have a widget to test in a left menu panel, but it can also appear on the right, accessible from a different selector. Or it might appear on different pages. It might also behave slightly differently depending on which one it is. Or you might have different browser instances in play, and need to control different ones, having them all in-play at once.</p>

<p>Just like optimization, premature refactoring, also known as speculative generalization, can be bad. Instead, do Continous/<a href="http://martinfowler.com/bliki/OpportunisticRefactoring.html">opportunistic refactoring</a>. Until you have 3 tests or more, you might not really be able to see what is common to them, and you might get yourself stuck in multiple layers of asynchronous test code and related page objects that aren't particularly suited to your case.</p>

<p>Keep in mind: there might not even be a "right" abstraction for all your tests, and that's ok!</p>

<h3>What to do instead of page objects?</h3>

<p>Always in mind what you're trying to do in the tests.</p>

<ul class="fa-ul">
  <li><i class="fa-li fa fa-caret-right"></i> Finding element(s)</li>
  <li><i class="fa-li fa fa-caret-right"></i> Interacting with element(s)</li>
  <li><i class="fa-li fa fa-caret-right"></i> Asserting something about element(s)</li>
</ul>

<p>If you have a few tests of a repeated non-trivial group of actions, like a login, or maybe a drag and drop action between one part of a page and another, then factor them about to functions that group them. I would really consider not factoring out much more than that.</p>

<p>For example, consider the following test.</p>

{{#highlight 'javascript'}}
describe('my homepage', function() {
  it('should greet the named user', function() {
    browser.get('http://mypage.com');
    input = element(by.xpath('//label[text()="Name"]/following::input[1]'))
    input.sendKeys('Julie');
    greeting = element(by.xpath('//label[text()="Greeting"]/following::input[1]'))
    expect(greeting.getText()).toEqual('Hello Julie!');
  });
});
{{/highlight}}

<p>You can see, right here in these few lines of code, what the test is doing: how the elements are being found and how Protractor is interacting with them. I think each test of your suite should be this clear. This does mean they will be some repeat calls to <code class="inline">ElementFinder</code> functions, or maybe some repeated locators, but so be it!</p>

<h3>This doesn't sound very DRY... what when I need to change something?</h3>

<p>Consider (the?) two cases of changing something</h3>

<ul class="fa-ul">
  <li><i class="fa-li fa fa-caret-right"></i> Changing something trivial, like text or where an element is on a page</li>
  <li><i class="fa-li fa fa-caret-right"></i> Changing something non-trivial, like how a non-trivial group of widgets work together</li>
<ul>

<p>If your main concern is the first case, and you're worrying that you might have to do a bit of a search-replace in your tests, then my suspicion is that you're focussing on the wrong thing. At most it's a few minutes of something a bit boring. I think it's <em>much</em> more important to make the tests easier to deal with if you change something non-trivial. In which case, clarity of what's going on in the tests are paramount.</p>
